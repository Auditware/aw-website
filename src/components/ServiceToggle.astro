---
export interface Props {
  title: string;
  subtitle?: string;
  services: Array<{
    id: string;
    name: string;
    description: string;
    features: string[];
    primary?: string;
    support?: string;
    scope?: string;
    image: string;
    imageAlt: string;
  }>;
}

const { title, subtitle, services } = Astro.props;
---

<section class="service-section section">
  <div class="container">
    <div class="service-header text-center">
      <h2 class="h2">{title}</h2>
      {subtitle && (
        <p class="body-large" style="margin-top: var(--spacing-4); max-width: 600px; margin-left: auto; margin-right: auto;">
          {subtitle}
        </p>
      )}
    </div>
    
    <div class="service-toggle-container">
      <div class="service-toggle" id="service-toggle">
        <div class="service-toggle-indicator"></div>
        {services.map((service, index) => (
          <button 
            class={`service-toggle-item ${index === 0 ? 'active' : ''}`}
            data-service={service.id}
          >
            {service.name}
          </button>
        ))}
      </div>
    </div>
    
    <div class="service-content">
      {services.map((service, index) => (
        <div 
          class={`service-panel ${index === 0 ? 'active' : ''}`}
          data-panel={service.id}
        >
          <div class="service-block">
            <h3 class="h3 gradient-text">{service.name}</h3>
            {service.primary && (
              <p class="body-large service-primary">{service.primary}</p>
            )}
            {service.support && (
              <p class="body-base service-support">{service.support}</p>
            )}
            {service.scope && (
              <p class="body-base service-scope">{service.scope}</p>
            )}
            <div class="service-visual">
              <div class="service-image-container">
                <img 
                  src={service.image} 
                  alt={service.imageAlt}
                  class="service-image"
                  loading="lazy"
                />
                <div class="service-image-glow"></div>
              </div>
            </div>
          </div>
        </div>
      ))}
    </div>
  </div>
</section>

<script>
  // Service toggle functionality
  document.addEventListener('DOMContentLoaded', function() {
    const toggleItems = document.querySelectorAll('.service-toggle-item');
    const panels = document.querySelectorAll('.service-panel');
    const indicator = document.querySelector('.service-toggle-indicator');
    const toggle = document.querySelector('.service-toggle');
    const contentContainer = document.querySelector('.service-content');
    
    function updateIndicator(activeItem) {
      if (!indicator || !toggle) return;
      
      const toggleRect = toggle.getBoundingClientRect();
      const itemRect = activeItem.getBoundingClientRect();
      
      // Calculate position relative to toggle container
      const left = itemRect.left - toggleRect.left;
      const width = itemRect.width;
      
      indicator.style.width = `${width}px`;
      indicator.style.transform = `translateX(${left}px)`;
    }
    
    function updateContainerHeight() {
      if (!contentContainer) return;
      
      // Find the tallest panel by measuring all panels
      let maxHeight = 0;
      
      panels.forEach((panel) => {
        const isActive = panel.classList.contains('active');
        
        // Temporarily show panel to measure
        const originalPosition = panel.style.position;
        const originalOpacity = panel.style.opacity;
        const originalVisibility = panel.style.visibility;
        const originalPointerEvents = panel.style.pointerEvents;
        const originalZIndex = panel.style.zIndex;
        
        // Force panel to be visible for measurement
        panel.style.position = 'relative';
        panel.style.opacity = '1';
        panel.style.visibility = 'visible';
        panel.style.pointerEvents = 'none';
        panel.style.zIndex = '-1';
        panel.style.height = 'auto';
        
        // Force a reflow to ensure accurate measurement
        void panel.offsetHeight;
        
        // Use scrollHeight to get full content height including margins and overflow
        const height = Math.max(panel.scrollHeight, panel.offsetHeight);
        if (height > maxHeight) {
          maxHeight = height;
        }
        
        // Restore original state based on active status
        if (isActive) {
          panel.style.position = 'relative';
          panel.style.opacity = '1';
          panel.style.visibility = 'visible';
          panel.style.pointerEvents = 'auto';
          panel.style.zIndex = '';
          panel.style.height = '';
        } else {
          panel.style.position = originalPosition || 'absolute';
          panel.style.opacity = originalOpacity || '0';
          panel.style.visibility = originalVisibility || 'hidden';
          panel.style.pointerEvents = originalPointerEvents || 'none';
          panel.style.zIndex = originalZIndex || '';
          panel.style.height = '';
        }
      });
      
      // Set container height to tallest panel with a small buffer for margins
      if (maxHeight > 0) {
        contentContainer.style.height = `${maxHeight + 40}px`;
        contentContainer.style.minHeight = `${maxHeight + 40}px`;
      }
    }
    
    // Wait for all images to load before calculating height
    function waitForImages(callback) {
      const images = document.querySelectorAll('.service-image');
      let loadedCount = 0;
      const totalImages = images.length;
      
      if (totalImages === 0) {
        callback();
        return;
      }
      
      images.forEach((img) => {
        if (img.complete) {
          loadedCount++;
          if (loadedCount === totalImages) {
            callback();
          }
        } else {
          img.addEventListener('load', () => {
            loadedCount++;
            if (loadedCount === totalImages) {
              callback();
            }
          });
          img.addEventListener('error', () => {
            loadedCount++;
            if (loadedCount === totalImages) {
              callback();
            }
          });
        }
      });
    }
    
    // Initialize first panel state explicitly
    const firstPanel = document.querySelector('.service-panel.active') || document.querySelector('.service-panel:first-child');
    if (firstPanel) {
      firstPanel.classList.add('active');
      firstPanel.style.position = 'relative';
      firstPanel.style.opacity = '1';
      firstPanel.style.visibility = 'visible';
      firstPanel.style.pointerEvents = 'auto';
      
      // Ensure other panels are hidden
      panels.forEach((panel, index) => {
        if (panel !== firstPanel) {
          panel.classList.remove('active');
          panel.style.position = 'absolute';
          panel.style.opacity = '0';
          panel.style.visibility = 'hidden';
          panel.style.pointerEvents = 'none';
        }
      });
    }
    
    // Initialize indicator position for first active item
    const firstActive = document.querySelector('.service-toggle-item.active') || document.querySelector('.service-toggle-item:first-child');
    if (firstActive) {
      if (!firstActive.classList.contains('active')) {
        firstActive.classList.add('active');
      }
      if (indicator) {
        // Small delay to ensure layout is complete
        requestAnimationFrame(() => {
          updateIndicator(firstActive);
        });
      }
    }
    
    // Initialize container height immediately and after images load
    requestAnimationFrame(() => {
      updateContainerHeight();
    });
    
    waitForImages(() => {
      // Small delay to ensure layout is complete
      requestAnimationFrame(() => {
        updateContainerHeight();
      });
    });
    
    // Update height on window resize
    let resizeTimeout;
    window.addEventListener('resize', function() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        waitForImages(() => {
          updateContainerHeight();
        });
      }, 100);
    });
    
    // Update height when images load (for lazy-loaded images)
    const imageObserver = new MutationObserver(() => {
      waitForImages(() => {
        updateContainerHeight();
      });
    });
    
    // Observe service-content for image additions
    if (contentContainer) {
      imageObserver.observe(contentContainer, {
        childList: true,
        subtree: true
      });
    }
    
    toggleItems.forEach(item => {
      item.addEventListener('click', function() {
        const serviceId = this.getAttribute('data-service');
        
        // Remove active class from all items and panels
        toggleItems.forEach(toggle => toggle.classList.remove('active'));
        panels.forEach(panel => {
          panel.classList.remove('active');
          // Only set inline styles if not using CSS classes
          if (!panel.classList.contains('active')) {
            panel.style.opacity = '';
            panel.style.pointerEvents = '';
            panel.style.position = '';
            panel.style.visibility = '';
          }
        });
        
        // Add active class to clicked item
        this.classList.add('active');
        
        // Show corresponding panel
        const targetPanel = document.querySelector(`[data-panel="${serviceId}"]`);
        if (targetPanel) {
          targetPanel.classList.add('active');
          targetPanel.style.position = 'relative';
          targetPanel.style.opacity = '1';
          targetPanel.style.visibility = 'visible';
          targetPanel.style.pointerEvents = 'auto';
          
          // Update indicator position after panel is shown
          requestAnimationFrame(() => {
            updateIndicator(this);
            // Update container height after layout
            requestAnimationFrame(() => {
              waitForImages(() => {
                updateContainerHeight();
              });
            });
          });
        }
      });
    });
  });
</script>

<style>
  .service-section {
    background: var(--color-background-primary);
  }
  
  .service-header {
    margin-bottom: var(--spacing-8);
  }
  
  .service-toggle-container {
    display: flex;
    justify-content: center;
    margin-bottom: var(--spacing-16);
  }
  
  .service-toggle {
    background: transparent;
    border: none;
    padding: 0;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--spacing-2);
    position: relative;
    width: 100%;
    max-width: 800px;
    min-width: 0;
  }
  
  .service-toggle-indicator {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: var(--color-background-secondary);
    border-radius: var(--radius-md);
    transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 0;
    pointer-events: none;
    width: 0;
  }
  
  .service-toggle-item {
    padding: var(--spacing-4) var(--spacing-8);
    border-radius: var(--radius-md);
    background: transparent;
    color: var(--color-text-secondary);
    font-weight: var(--font-weight-medium);
    font-size: var(--font-size-base);
    line-height: 1.5;
    transition: color var(--transition-base);
    cursor: pointer;
    border: none;
    white-space: nowrap;
    position: relative;
    z-index: 1;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    min-height: 44px;
    box-sizing: border-box;
  }
  
  .service-toggle-item.active {
    color: var(--color-text-primary);
    font-weight: var(--font-weight-medium);
  }
  
  .service-toggle-item:hover:not(.active) {
    color: var(--color-text-secondary);
    opacity: 0.8;
  }
  
  .service-content {
    position: relative;
    width: 100%;
    overflow: visible;
  }
  
  .service-panel {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s ease-out;
    width: 100%;
    visibility: hidden;
  }
  
  .service-panel.active {
    opacity: 1 !important;
    pointer-events: auto !important;
    position: relative !important;
    visibility: visible !important;
  }
  
  /* Ensure first panel is visible on initial load */
  .service-panel:first-child {
    position: relative;
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }
  
  .service-panel:first-child:not(.active) {
    position: absolute;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
  }
  
  .service-block {
    display: flex;
    flex-direction: column;
    max-width: 800px;
    margin: 0 auto;
  }
  
  .service-block .h3 {
    margin-bottom: var(--spacing-4);
    text-align: center;
  }
  
  .service-primary {
    margin-bottom: var(--spacing-4);
    text-align: center;
  }
  
  .service-support {
    color: var(--color-text-secondary);
    line-height: 1.75;
    margin-top: 0;
    margin-bottom: var(--spacing-3);
    text-align: center;
  }
  
  .service-scope {
    color: var(--color-text-secondary);
    line-height: 1.75;
    margin-top: 0;
    margin-bottom: var(--spacing-8);
    text-align: center;
  }
  
  .service-visual {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: var(--spacing-6);
    overflow: visible;
  }
  
  .service-image-container {
    position: relative;
    max-width: 480px;
    width: 100%;
    margin: 0 auto;
    overflow: visible;
    aspect-ratio: 480 / 290;
    min-height: 290px;
  }
  
  .service-image {
    width: 100%;
    height: 100%;
    max-width: 480px;
    max-height: 290px;
    object-fit: cover;
    object-position: center;
    border-radius: var(--radius-xl);
    box-shadow: 
      0 1px 3px rgba(0, 0, 0, 0.12),
      0 4px 12px rgba(0, 0, 0, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.08);
    opacity: 0.95;
    display: block;
    background: var(--color-background-secondary);
  }
  
  .service-image-glow {
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    bottom: 15px;
    background: linear-gradient(
      135deg,
      rgba(139, 92, 246, 0.12) 0%,
      rgba(124, 58, 237, 0.08) 100%
    );
    border-radius: var(--radius-xl);
    opacity: 0.6;
    filter: blur(40px);
    z-index: -1;
  }
  
  /* Responsive Design */
  @media (max-width: 1199px) {
    .service-block {
      max-width: 100%;
    }
  }
  
  @media (max-width: 767px) {
    .service-toggle {
      grid-template-columns: 1fr;
      width: 100%;
      max-width: 400px;
      gap: var(--spacing-3);
    }
    
    .service-toggle-item {
      text-align: center;
      width: 100%;
    }
    
    .service-toggle-indicator {
      width: 100% !important;
      transform: none !important;
      top: auto;
      bottom: 0;
      height: 2px;
      border-radius: 0;
    }
    
    .service-block {
      max-width: 100%;
    }
  }
  
  @media (max-width: 479px) {
    .service-toggle-container {
      padding: 0 var(--spacing-4);
    }
    
    .service-toggle {
      max-width: none;
    }
    
    .service-block {
      max-width: 100%;
    }
  }
</style>
